'use strict';

exports.__esModule = true;
exports.HorizonSocket = undefined;

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _AsyncSubject = require('rxjs/AsyncSubject');

var _BehaviorSubject = require('rxjs/BehaviorSubject');

var _WebSocketSubject2 = require('rxjs/observable/dom/WebSocketSubject');

var _Observable = require('rxjs/Observable');

var _Subscription = require('rxjs/Subscription');

require('rxjs/add/observable/merge');

require('rxjs/add/observable/timer');

require('rxjs/add/operator/filter');

require('rxjs/add/operator/share');

require('rxjs/add/operator/ignoreElements');

require('rxjs/add/operator/concat');

require('rxjs/add/operator/takeWhile');

require('rxjs/add/operator/publish');

var _serialization = require('./serialization.js');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PROTOCOL_VERSION = 'rethinkdb-horizon-v0';

// Before connecting the first time
var STATUS_UNCONNECTED = { type: 'unconnected' };
// After the websocket is opened and handshake is completed
var STATUS_READY = { type: 'ready' };
// After unconnected, maybe before or after connected. Any socket level error
var STATUS_ERROR = { type: 'error' };
// Occurs when the socket closes
var STATUS_DISCONNECTED = { type: 'disconnected' };

var ProtocolError = function (_Error) {
  (0, _inherits3.default)(ProtocolError, _Error);

  function ProtocolError(msg, errorCode) {
    (0, _classCallCheck3.default)(this, ProtocolError);

    var _this = (0, _possibleConstructorReturn3.default)(this, _Error.call(this, msg));

    _this.errorCode = errorCode;
    return _this;
  }

  ProtocolError.prototype.toString = function toString() {
    return this.message + ' (Code: ' + this.errorCode + ')';
  };

  return ProtocolError;
}(Error);

// Wraps native websockets with a Subject, which is both an Subscriber
// and an Observable (it is bi-directional after all!). This version
// is based on the rxjs.observable.dom.WebSocketSubject implementation.


var HorizonSocket = exports.HorizonSocket = function (_WebSocketSubject) {
  (0, _inherits3.default)(HorizonSocket, _WebSocketSubject);

  // Deserializes a message from a string. Overrides the version
  // implemented in WebSocketSubject
  HorizonSocket.prototype.resultSelector = function resultSelector(e) {
    return (0, _serialization.deserialize)(JSON.parse(e.data));
  };

  // We're overriding the next defined in AnonymousSubject so we
  // always serialize the value. When this is called a message will be
  // sent over the socket to the server.


  HorizonSocket.prototype.next = function next(value) {
    var request = JSON.stringify((0, _serialization.serialize)(value));
    _WebSocketSubject.prototype.next.call(this, request);
  };

  function HorizonSocket() {
    var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    var url = _ref.url;
    var handshakeMaker = _ref.handshakeMaker;
    var _ref$keepalive = _ref.keepalive;
    var keepalive = _ref$keepalive === undefined ? 60 : _ref$keepalive;
    var _ref$WebSocketCtor = _ref.WebSocketCtor;
    var WebSocketCtor = _ref$WebSocketCtor === undefined ? WebSocket : _ref$WebSocketCtor;
    (0, _classCallCheck3.default)(this, HorizonSocket);

    // Completes or errors based on handshake success. Buffers
    // handshake response for later subscribers (like a Promise)
    var _this2 = (0, _possibleConstructorReturn3.default)(this, _WebSocketSubject.call(this, {
      url: url,
      protocol: PROTOCOL_VERSION,
      WebSocketCtor: WebSocketCtor,
      openObserver: {
        next: function next() {
          return _this2.sendHandshake();
        }
      },
      closeObserver: {
        next: function next() {
          if (_this2._handshakeSub) {
            _this2._handshakeSub.unsubscribe();
            _this2._handshakeSub = null;
          }
          _this2.status.next(STATUS_DISCONNECTED);
        }
      }
    }));

    _this2.handshake = new _AsyncSubject.AsyncSubject();
    _this2._handshakeMaker = handshakeMaker;
    _this2._handshakeSub = null;

    _this2.keepalive = _Observable.Observable.timer(keepalive * 1000, keepalive * 1000).map(function (n) {
      return _this2.makeRequest({ type: 'keepalive' }).subscribe();
    }).publish();

    // This is used to emit status changes that others can hook into.
    _this2.status = new _BehaviorSubject.BehaviorSubject(STATUS_UNCONNECTED);
    // Keep track of subscribers so we's can decide when to
    // unsubscribe.
    _this2.requestCounter = 0;
    // A map from request_ids to an object with metadata about the
    // request. Eventually, this should allow re-sending requests when
    // reconnecting.
    _this2.activeRequests = new Map();
    _this2._output.subscribe({
      // This emits if the entire socket errors (usually due to
      // failure to connect)
      error: function error() {
        return _this2.status.next(STATUS_ERROR);
      }
    });
    return _this2;
  }

  HorizonSocket.prototype.deactivateRequest = function deactivateRequest(req) {
    var _this3 = this;

    return function () {
      _this3.activeRequests.delete(req.request_id);
      return { request_id: req.request_id, type: 'end_subscription' };
    };
  };

  HorizonSocket.prototype.activateRequest = function activateRequest(req) {
    var _this4 = this;

    return function () {
      _this4.activeRequests.set(req.request_id, req);
      return req;
    };
  };

  HorizonSocket.prototype.filterRequest = function filterRequest(req) {
    return function (resp) {
      return resp.request_id === req.request_id;
    };
  };

  HorizonSocket.prototype.getRequest = function getRequest(request) {
    return Object.assign({ request_id: this.requestCounter++ }, request);
  };

  // This is a trimmed-down version of multiplex that only listens for
  // the handshake requestId. It also starts the keepalive observable
  // and cleans up after it when the handshake is cleaned up.


  HorizonSocket.prototype.sendHandshake = function sendHandshake() {
    var _this5 = this;

    if (!this._handshakeSub) {
      this._handshakeSub = this.makeRequest(this._handshakeMaker()).subscribe({
        next: function next(n) {
          if (n.error) {
            _this5.status.next(STATUS_ERROR);
            _this5.handshake.error(new ProtocolError(n.error, n.error_code));
          } else {
            _this5.status.next(STATUS_READY);
            _this5.handshake.next(n);
            _this5.handshake.complete();
          }
        },
        error: function error(e) {
          _this5.status.next(STATUS_ERROR);
          _this5.handshake.error(e);
        }
      });

      // Start the keepalive and make sure it's
      // killed when the handshake is cleaned up
      this._handshakeSub.add(this.keepalive.connect());
    }
    return this.handshake;
  };

  // Incorporates shared logic between the inital handshake request and
  // all subsequent requests.
  // * Generates a request id and filters by it
  // * Send `end_subscription` when observable is unsubscribed


  HorizonSocket.prototype.makeRequest = function makeRequest(rawRequest) {
    var request = this.getRequest(rawRequest);

    return _WebSocketSubject.prototype.multiplex.call(this, this.activateRequest(request), this.deactivateRequest(request), this.filterRequest(request));
  };

  // Wrapper around the makeRequest with the following additional
  // features we need for horizon's protocol:
  // * Sends handshake on subscription if it hasn't happened already
  // * Wait for the handshake to complete before sending the request
  // * Errors when a document with an `error` field is received
  // * Completes when `state: complete` is received
  // * Emits `state: synced` as a separate document for easy filtering
  // * Reference counts subscriptions


  HorizonSocket.prototype.hzRequest = function hzRequest(rawRequest) {
    return this.sendHandshake().ignoreElements().concat(this.makeRequest(rawRequest)).concatMap(function (resp) {
      if (resp.error !== undefined) {
        throw new ProtocolError(resp.error, resp.error_code);
      }
      var data = resp.data || [];

      if (resp.state !== undefined) {
        // Create a little dummy object for sync notifications
        data.push({
          type: 'state',
          state: resp.state
        });
      }

      return data;
    }).share();
  };

  return HorizonSocket;
}(_WebSocketSubject2.WebSocketSubject);
//# sourceMappingURL=socket.js.map