{"version":3,"sources":["../src/socket.js"],"names":["PROTOCOL_VERSION","STATUS_UNCONNECTED","type","STATUS_READY","STATUS_ERROR","STATUS_DISCONNECTED","ProtocolError","msg","errorCode","toString","message","Error","HorizonSocket","resultSelector","e","JSON","parse","data","next","value","request","stringify","url","handshakeMaker","keepalive","WebSocketCtor","WebSocket","protocol","openObserver","sendHandshake","closeObserver","_handshakeSub","unsubscribe","status","handshake","_handshakeMaker","timer","map","makeRequest","subscribe","publish","requestCounter","activeRequests","Map","_output","error","deactivateRequest","req","delete","request_id","activateRequest","set","filterRequest","resp","getRequest","Object","assign","n","error_code","complete","add","connect","rawRequest","multiplex","hzRequest","ignoreElements","concat","concatMap","undefined","state","push","share"],"mappings":"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","file":"socket.js","sourcesContent":["import { AsyncSubject } from 'rxjs/AsyncSubject'\nimport { BehaviorSubject } from 'rxjs/BehaviorSubject'\nimport { WebSocketSubject } from 'rxjs/observable/dom/WebSocketSubject'\nimport { Observable } from 'rxjs/Observable'\nimport { Subscription } from 'rxjs/Subscription'\nimport 'rxjs/add/observable/merge'\nimport 'rxjs/add/observable/timer'\nimport 'rxjs/add/operator/filter'\nimport 'rxjs/add/operator/share'\nimport 'rxjs/add/operator/ignoreElements'\nimport 'rxjs/add/operator/concat'\nimport 'rxjs/add/operator/takeWhile'\nimport 'rxjs/add/operator/publish'\n\nimport { serialize, deserialize } from './serialization.js'\n\nconst PROTOCOL_VERSION = 'rethinkdb-horizon-v0'\n\n// Before connecting the first time\nconst STATUS_UNCONNECTED = { type: 'unconnected' }\n// After the websocket is opened and handshake is completed\nconst STATUS_READY = { type: 'ready' }\n// After unconnected, maybe before or after connected. Any socket level error\nconst STATUS_ERROR = { type: 'error' }\n// Occurs when the socket closes\nconst STATUS_DISCONNECTED = { type: 'disconnected' }\n\nclass ProtocolError extends Error {\n  constructor(msg, errorCode) {\n    super(msg)\n    this.errorCode = errorCode\n  }\n  toString() {\n    return `${this.message} (Code: ${this.errorCode})`\n  }\n}\n\n\n// Wraps native websockets with a Subject, which is both an Subscriber\n// and an Observable (it is bi-directional after all!). This version\n// is based on the rxjs.observable.dom.WebSocketSubject implementation.\nexport class HorizonSocket extends WebSocketSubject {\n  // Deserializes a message from a string. Overrides the version\n  // implemented in WebSocketSubject\n  resultSelector(e) {\n    return deserialize(JSON.parse(e.data))\n  }\n\n  // We're overriding the next defined in AnonymousSubject so we\n  // always serialize the value. When this is called a message will be\n  // sent over the socket to the server.\n  next(value) {\n    const request = JSON.stringify(serialize(value))\n    super.next(request)\n  }\n\n  constructor({\n    url,              // Full url to connect to\n    handshakeMaker, // function that returns handshake to emit\n    keepalive = 60,   // seconds between keepalive messages\n    WebSocketCtor = WebSocket,    // optionally provide a WebSocket constructor\n  } = {}) {\n    super({\n      url,\n      protocol: PROTOCOL_VERSION,\n      WebSocketCtor,\n      openObserver: {\n        next: () => this.sendHandshake(),\n      },\n      closeObserver: {\n        next: () => {\n          if (this._handshakeSub) {\n            this._handshakeSub.unsubscribe()\n            this._handshakeSub = null\n          }\n          this.status.next(STATUS_DISCONNECTED)\n        },\n      },\n    })\n    // Completes or errors based on handshake success. Buffers\n    // handshake response for later subscribers (like a Promise)\n    this.handshake = new AsyncSubject()\n    this._handshakeMaker = handshakeMaker\n    this._handshakeSub = null\n\n    this.keepalive = Observable\n      .timer(keepalive * 1000, keepalive * 1000)\n      .map(n => this.makeRequest({ type: 'keepalive' }).subscribe())\n      .publish()\n\n    // This is used to emit status changes that others can hook into.\n    this.status = new BehaviorSubject(STATUS_UNCONNECTED)\n    // Keep track of subscribers so we's can decide when to\n    // unsubscribe.\n    this.requestCounter = 0\n    // A map from request_ids to an object with metadata about the\n    // request. Eventually, this should allow re-sending requests when\n    // reconnecting.\n    this.activeRequests = new Map()\n    this._output.subscribe({\n      // This emits if the entire socket errors (usually due to\n      // failure to connect)\n      error: () => this.status.next(STATUS_ERROR),\n    })\n  }\n\n  deactivateRequest(req) {\n    return () => {\n      this.activeRequests.delete(req.request_id)\n      return { request_id: req.request_id, type: 'end_subscription' }\n    }\n  }\n\n  activateRequest(req) {\n    return () => {\n      this.activeRequests.set(req.request_id, req)\n      return req\n    }\n  }\n\n  filterRequest(req) {\n    return resp => resp.request_id === req.request_id\n  }\n\n  getRequest(request) {\n    return Object.assign({ request_id: this.requestCounter++ }, request)\n  }\n\n  // This is a trimmed-down version of multiplex that only listens for\n  // the handshake requestId. It also starts the keepalive observable\n  // and cleans up after it when the handshake is cleaned up.\n  sendHandshake() {\n    if (!this._handshakeSub) {\n      this._handshakeSub = this.makeRequest(this._handshakeMaker())\n        .subscribe({\n          next: n => {\n            if (n.error) {\n              this.status.next(STATUS_ERROR)\n              this.handshake.error(new ProtocolError(n.error, n.error_code))\n            } else {\n              this.status.next(STATUS_READY)\n              this.handshake.next(n)\n              this.handshake.complete()\n            }\n          },\n          error: e => {\n            this.status.next(STATUS_ERROR)\n            this.handshake.error(e)\n          },\n        })\n\n      // Start the keepalive and make sure it's\n      // killed when the handshake is cleaned up\n      this._handshakeSub.add(this.keepalive.connect())\n    }\n    return this.handshake\n  }\n\n  // Incorporates shared logic between the inital handshake request and\n  // all subsequent requests.\n  // * Generates a request id and filters by it\n  // * Send `end_subscription` when observable is unsubscribed\n  makeRequest(rawRequest) {\n    const request = this.getRequest(rawRequest)\n\n    return super.multiplex(\n      this.activateRequest(request),\n      this.deactivateRequest(request),\n      this.filterRequest(request)\n    )\n  }\n\n  // Wrapper around the makeRequest with the following additional\n  // features we need for horizon's protocol:\n  // * Sends handshake on subscription if it hasn't happened already\n  // * Wait for the handshake to complete before sending the request\n  // * Errors when a document with an `error` field is received\n  // * Completes when `state: complete` is received\n  // * Emits `state: synced` as a separate document for easy filtering\n  // * Reference counts subscriptions\n  hzRequest(rawRequest) {\n    return this.sendHandshake().ignoreElements()\n      .concat(this.makeRequest(rawRequest))\n      .concatMap(resp => {\n        if (resp.error !== undefined) {\n          throw new ProtocolError(resp.error, resp.error_code)\n        }\n        const data = resp.data || []\n\n        if (resp.state !== undefined) {\n          // Create a little dummy object for sync notifications\n          data.push({\n            type: 'state',\n            state: resp.state,\n          })\n        }\n\n        return data\n      })\n      .share()\n  }\n}\n"]}